//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

class Tuple {

	public String var;
	public int arg1;
	public int arg2;
	public boolean arg;

	public Tuple(){
		this.var = "";
		this.arg1 = 0;
		this.arg2 = 0;
	}

	public Tuple(String var, int arg1, int arg2){
		this.var = var;
		this.arg1 = arg1;
		this.arg2 = arg2;
	}

}

class SymbolTable{

	HashMap<String, MethodTable> methodList;
	MethodTable curr_method;

	SymbolTable(){
		methodList = new HashMap<String, MethodTable>();
		curr_method = null;
	}

	void addMethod(String name, String argc){
		MethodTable new_method = new MethodTable(name, argc);
		methodList.put(name, new_method);
	}

}

class MethodTable{

	String name;
	String argc;
	String [] Register;
	int regc;
	int callc;

	LinkedHashMap<String, BlockTable> labelMap;
  LinkedHashMap<Integer, BlockTable> blockMap;
	LinkedHashMap<String, String> regMap;
	LinkedHashMap<String, String> spillMap;
	LinkedHashMap<String, Tuple> intervalMap; 
	LinkedHashSet<String> Temp;
  String curr_label;
  BlockTable curr_block;
  int block_count;
	int spill_count;
	boolean spill;

	int stackSlots;
	int sp;
	int tp;
	int spillp;
	int arg_block0;

	MethodTable(){

		this.name = null;
		this.argc = null;
		this.Register = new String[]{"s0","s1","s2","s3","s4","s5","s6","s7","t0","t1","t2","t3","t4","t5","t6","t7","t8","t9"};
		this.regc = this.Register.length;
		this.callc = 0;
	
		this.labelMap = new LinkedHashMap<String, BlockTable>();
		this.blockMap = new LinkedHashMap<Integer, BlockTable>();
		this.regMap = new LinkedHashMap<String, String>();
		this.spillMap = new LinkedHashMap<String, String>();
		this.intervalMap = new LinkedHashMap<String, Tuple>();
		this.Temp = new LinkedHashSet<String>();
		this.curr_label = null;
		this.curr_block = null;
		this.block_count = 1;
		this.spill_count = 0;
		this.spill = false;

		this.stackSlots = 0;
		this.sp = 0;
		this.tp = 0;
		this.spillp = 0;
		this.arg_block0 = 0;
	}

	MethodTable(String name, String argc){

		this.name = name;
		this.argc = argc;
		this.Register = new String[]{"s0","s1","s2","s3","s4","s5","s6","s7","t0","t1","t2","t3","t4","t5","t6","t7","t8","t9"};
		this.regc = this.Register.length;
		this.callc = 0;
	
		this.labelMap = new LinkedHashMap<String, BlockTable>();
		this.blockMap = new LinkedHashMap<Integer, BlockTable>();
		this.regMap = new LinkedHashMap<String, String>();
		this.spillMap = new LinkedHashMap<String, String>();
		this.intervalMap = new LinkedHashMap<String, Tuple>();
		this.Temp = new LinkedHashSet<String>();
		this.curr_label = null;
		this.curr_block = null;
		this.block_count = 1;
		this.spill_count = 0;
		this.spill = false;

		this.stackSlots = 0;
		this.sp = 0;
		this.tp = 0;
		this.spillp = 0;
		this.arg_block0 = 0;
	}

	void setBlock(int addr){
		this.curr_block = blockMap.get(addr);
	}

	void resetBlock(){
		this.curr_block = null;
	}

	int addBlock(){
		BlockTable node;
		if(this.curr_label != null){
      node = labelMap.get(curr_label);
    }
    else {
      node = new BlockTable();
    }
		if(blockMap.containsKey(block_count-1)){
			BlockTable parent = blockMap.get(block_count-1);
			parent.addNext(node);
		}

		blockMap.put(block_count, node);

		return block_count++;
	}

	void addLabel(String label){
		if(labelMap.containsKey(label)){
			this.curr_label = label;
		}
		else{
			BlockTable node = new BlockTable(label);
			labelMap.put(label, node);
		}
	}

	int getLast(String str){
		int ret = -1;

		for(int i = this.block_count -1; i >= 0; i--){
			if(blockMap.get(i).in.contains(str)){
				ret = i;
				break;
			}
		}

		return ret;
	}

	int getFirst(String str){
		int ret = this.block_count;

		for(int i = 0; i < this.block_count; i++){
			if(blockMap.get(i).def.contains(str)){
				ret = i;
				break;
			}
		}

		return ret;
	}

	void initStackSlots(){
		if(Integer.parseInt(this.argc) >= 5)
			this.stackSlots = this.stackSlots + (Integer.parseInt(this.argc) - 4); 
		
		this.sp = this.stackSlots;

		if(this.name != "MAIN")
			this.stackSlots = this.stackSlots + 8;

		this.tp = this.stackSlots;

		if(this.callc >=0)
			this.stackSlots = this.stackSlots + 10;
		
		this.spillp = this.stackSlots;

		spillMap.replaceAll((k, v) -> Integer.toString(Integer.parseInt(v) + this.spillp));

		for(int i =4; i < Integer.parseInt(this.argc); i++)
			spillMap.put("TEMP" + Integer.toString(i), Integer.toString(i-4));
		
		this.stackSlots = this.stackSlots + this.spill_count;
	}

	void analyseLive(){
		BlockTable snode = new BlockTable();
		this.arg_block0 = Math.min(4, Integer.parseInt(this.argc));

		for(int i = 0; i < this.arg_block0; i++)
			snode.def.add("TEMP" + i);

		snode.next.add(blockMap.get(1));
		blockMap.put(0,snode);

		boolean flag = false;
		do{
			flag = false;

			Iterator it = blockMap.entrySet().iterator();
			while(it.hasNext()){
				Map.Entry pair = (Map.Entry)it.next();
				Integer key = (Integer)pair.getKey();
				BlockTable node = (BlockTable)pair.getValue();

				node.copySet(1);
				node.copySet(2);
				node.setIn();
				node.setOut();
			}

			it = blockMap.entrySet().iterator();
			while(it.hasNext()){
				Map.Entry pair = (Map.Entry)it.next();
				Integer key = (Integer)pair.getKey();
				BlockTable node = (BlockTable)pair.getValue();

				flag = !node.checkSet();
			}
		}
		while(flag);

		this.updateLiveRanges();
	}

	void updateLiveRanges(){
		for(int i = 4; i < Integer.parseInt(this.argc); i++)
			this.Temp.remove("TEMP"+Integer.toString(i));

		Iterator<String> it = this.Temp.iterator();
		while(it.hasNext()){
			String nxt = it.next();
			int first = this.getFirst(nxt);
			int last = this.getLast(nxt);

			if(first > last)
				it.remove();
			
			Tuple live_range = new Tuple(nxt, first, last);
			intervalMap.put(nxt, live_range);
		}
	}

	void LinearScan(){
		ArrayList<Tuple> liveIntervals = new ArrayList<Tuple>();
    ArrayList<Tuple> activeIntervals = new ArrayList<Tuple>();
    ArrayList<Integer> activeRegisters = new ArrayList<Integer>();

		boolean [] freeReg = new boolean[18];
		for(int i = 0; i < 18; i++)
			freeReg[i] = true;
		
		Iterator it = intervalMap.entrySet().iterator();
    while(it.hasNext()){
      Map.Entry pair = (Map.Entry)it.next();
      Tuple curr_range = (Tuple)pair.getValue();
      int pos = -1;

      for(int i = 0; i < liveIntervals.size(); i++){
        if(liveIntervals.get(i).arg1 > curr_range.arg1){
          pos = i;
          break;
          }
        }

        if(pos == -1)
          liveIntervals.add(curr_range);
      	else
          liveIntervals.add(pos,curr_range);
			}

		for(int i = 0; i < liveIntervals.size(); i++){
   	  for(int j = 0;j < activeIntervals.size(); j++){
        if(activeIntervals.get(j).arg2 >= liveIntervals.get(i).arg1)
          break;
        else{
          freeReg[activeRegisters.get(j).intValue()] = true;
          activeIntervals.remove(j);
          activeRegisters.remove(j);
        }
      }

    	if(activeRegisters.size() == this.regc){
				this.spill = true;
        Tuple spill_t = activeIntervals.get(activeIntervals.size()-1);

        if(spill_t.arg2 > liveIntervals.get(i).arg2){
          int freshReg = activeRegisters.get(activeRegisters.size()-1).intValue();
          activeRegisters.remove(activeRegisters.size()-1);
          activeIntervals.remove(activeIntervals.size()-1);
            
          regMap.remove(spill_t.var);
          regMap.put(liveIntervals.get(i).var, this.Register[freshReg]);
          spillMap.put(spill_t.var, Integer.toString(spill_count++));

          int pos = -1;
          for(int j = 0; j < activeIntervals.size(); j++){
            if(activeIntervals.get(j).arg2 > liveIntervals.get(i).arg2){
              pos = j;
              break;
          	}
         	}

        	if(pos == -1){
          	activeIntervals.add(liveIntervals.get(i));
          	activeRegisters.add(Integer.valueOf(freshReg));
         	}
         	else{
           	activeIntervals.add(pos, liveIntervals.get(i));
           	activeRegisters.add(pos,Integer.valueOf(freshReg));
         	}
       	}
       	else
          spillMap.put(liveIntervals.get(i).var, Integer.toString(spill_count++));        
      }
      else{
        int freshReg=0;
        while(freshReg < 18){       
        	if(freeReg[freshReg]){
          	freeReg[freshReg] = false;
           	break;
         	}
         	freshReg++;
       	}

        regMap.put(liveIntervals.get(i).var,this.Register[freshReg]);

        int pos = -1;
        for(int j = 0;j < activeIntervals.size();++j){
        	if(activeIntervals.get(j).arg2 > liveIntervals.get(i).arg2){
            pos = j;
            break;
          }
      	}

        if(pos == -1){
          activeIntervals.add(liveIntervals.get(i));
          activeRegisters.add(Integer.valueOf(freshReg));
        }
      	else{
          activeIntervals.add(pos, liveIntervals.get(i));
          activeRegisters.add(pos,Integer.valueOf(freshReg));
        }
     	}
    }
   	this.initStackSlots();
	}
	
}

class BlockTable{

	String label;

	LinkedHashSet<String> use;
  LinkedHashSet<String> def;
  LinkedHashSet<String> in;
  LinkedHashSet<String> out;
  LinkedHashSet<String> in_t;
  LinkedHashSet<String> out_t;
  LinkedHashSet<BlockTable> next;

	BlockTable(){
		this.label = null;
		use = new LinkedHashSet<String>();
		def = new LinkedHashSet<String>();
		in = new LinkedHashSet<String>();
		out = new LinkedHashSet<String>();
		in_t = new LinkedHashSet<String>();
		out_t = new LinkedHashSet<String>();
		next = new LinkedHashSet<BlockTable>();
	}

	BlockTable(String label){
		this.label = label;
		use = new LinkedHashSet<String>();
		def = new LinkedHashSet<String>();
		in = new LinkedHashSet<String>();
		out = new LinkedHashSet<String>();
		in_t = new LinkedHashSet<String>();
		out_t = new LinkedHashSet<String>();
		next = new LinkedHashSet<BlockTable>();
	}

	void addUse(String str){
		this.use.add(str);
	}

	void addDef(String str){
		this.def.add(str);
	}

	void addNext(BlockTable node){
		this.next.add(node);
	}

	boolean checkSet(){
		return in_t.equals(in) && out_t.equals(out);
	}

	void  setIn(){
		this.in = new LinkedHashSet<String>();
		Iterator<String> it ;
		
		it = this.use.iterator();
		while(it.hasNext())
			this.in.add(it.next());

		LinkedHashSet temp = new LinkedHashSet<String>();

		it = this.out.iterator();
		while(it.hasNext()){
			String nxt = it.next();
			if(!this.def.contains(nxt))
				temp.add(nxt);
		}

		it = temp.iterator();
		while(it.hasNext()){
			String nxt = it.next();
			if(!this.in.contains(nxt))
				this.in.add(nxt);
		}
	}

	void setOut(){
		this.out = new LinkedHashSet<String>();
		Iterator<BlockTable> it = this.next.iterator();
		
		while(it.hasNext()){
			BlockTable child = it.next();
			Iterator<String> itr = child.in.iterator();

			while(itr.hasNext())
				this.out.add(itr.next());
		}
	}

	void copySet(int n){
		if(n == 1){
			this.in_t = new LinkedHashSet<String>();
			Iterator<String> it = this.in.iterator();
			while(it.hasNext())
				this.in_t.add(it.next());
		}
		else{
			this.out_t = new LinkedHashSet<String>();
			Iterator<String> it = this.out.iterator();
			while(it.hasNext())
				this.out_t.add(it.next());
		}
	}

}

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class RegAlloc<R,A> extends GJDepthFirst<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
  
	SymbolTable T = new SymbolTable();

  public R visit(NodeToken n, A argu) { return (R)n.tokenImage; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
  public R visit(Goal n, A argu) {
      R _ret=null;

      n.f0.accept(this, (A)"1");
        
    	T.addMethod("MAIN", "0");
      T.curr_method = T.methodList.get("MAIN");
        
      n.f1.accept(this, (A)"1");
      n.f2.accept(this, (A)"1");

      T.curr_method.analyseLive();
      T.curr_method.LinearScan();

      T.curr_method = null;
        
      n.f3.accept(this, (A)"1");
      n.f4.accept(this, (A)"1");
        
      n.f0.accept(this, (A)"2");

      T.curr_method = T.methodList.get("MAIN");
      System.out.println("MAIN [" + T.curr_method.argc + "] [" + T.curr_method.stackSlots + "] [" + T.curr_method.callc + "] " );
         
      n.f1.accept(this, (A)"2");
      n.f2.accept(this, (A)"2");

      System.out.println("END");
      if(T.curr_method.spill)
				System.out.println("//SPILLED");
      else
				System.out.println("//NOTSPILLED");
      T.curr_method = null;

      n.f3.accept(this, (A)"2");
      n.f4.accept(this, (A)"2");

      return _ret;
  }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      String label = "";

      if(n.f0.present()){
      	for(int i = 0; i < n.f0.size(); i++){
          if(((NodeOptional)((NodeSequence)n.f0.elementAt(i)).elementAt(0)).present()){
            label = (String) ((NodeSequence)n.f0.elementAt(i)).elementAt(0).accept(this,argu);
          	
						if(argu.toString().equals("1")){
              T.curr_method.addLabel(label);
            }

						T.curr_method.curr_label = label;
          } 
        	else{
            label = "";
          }

          if(argu.toString() == "2")
						if(label != "")
            	System.out.println(T.curr_method.name + label);

          ((NodeSequence)n.f0.elementAt(i)).elementAt(1).accept(this,argu);
          T.curr_method.curr_label = null;
        }
			}
    	return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      String name = "";
      String argc = "";

      switch(argu.toString()){
        case "1": 
          name = (String)n.f0.accept(this, argu);
          n.f1.accept(this, argu);
          argc = (String)n.f2.accept(this, argu);
          n.f3.accept(this, argu);
          T.addMethod(name,argc);
          T.curr_method = T.methodList.get(name);
          n.f4.accept(this, argu);
          T.curr_method.analyseLive();
          T.curr_method.LinearScan();
          T.curr_method = null;
          break;

        case "2":
          name = (String)n.f0.accept(this, argu);
          n.f1.accept(this, argu);
          argc = (String)n.f2.accept(this, argu);
          n.f3.accept(this, argu);
          T.curr_method = T.methodList.get(name);

          System.out.println(name + " [" + argc + "] [" + T.curr_method.stackSlots + "] [" + T.curr_method.callc + "] " );
            
          n.f4.accept(this, argu);
          if(T.curr_method.spill)
						System.out.println("//SPILLED");
          else
						System.out.println("//NOTSPILLED");
          T.curr_method = null;
          break;
        }
    	return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
        if(argu.toString().equals("1")){int index = T.curr_method.addBlock();}
        if(argu.toString().equals("2")){System.out.println("\tNOOP");}
        n.f0.accept(this, argu);
        return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
        if(argu.toString().equals("1")){int index = T.curr_method.addBlock();}
        if(argu.toString().equals("2")){System.out.println("\tERROR");}
        n.f0.accept(this, argu);
        return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      String temp = "";
      String label = "";
      int index = 0;

      switch(argu.toString()){
        case "1":
          index = T.curr_method.addBlock();
          T.curr_method.setBlock(index);
          n.f0.accept(this, argu);    
          temp = (String)n.f1.accept(this, argu);
          label = (String)n.f2.accept(this, argu);
          T.curr_method.curr_block.addUse(temp);
          T.curr_method.addLabel(label);
          T.curr_method.curr_block.addNext(T.curr_method.labelMap.get(label));
          T.curr_method.resetBlock();
          break;
      	case "2":
          n.f0.accept(this,argu);
          temp = (String)n.f1.accept(this,argu);
          label = (String)n.f2.accept(this,argu);
                
          if(T.curr_method.regMap.containsKey(temp)){
            System.out.println("\tCJUMP " + T.curr_method.regMap.get(temp) + " " +T.curr_method.name + label + " " );
          }
					else{
            System.out.println("\tALOAD v1 SPILLEDARG " + T.curr_method.spillMap.get(temp));
            System.out.println("\tCJUMP v1 " + T.curr_method.name + label);
          }
          break;
        }
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
    	String label = "";
      int index = 0;
      if(argu.toString() == "1"){
        index = T.curr_method.addBlock();
        T.curr_method.setBlock(index);
      }
      n.f0.accept(this, argu);
      label = (String)n.f1.accept(this, argu);

      if(argu.toString() == "1"){
        T.curr_method.addLabel(label);
        T.curr_method.curr_block.addNext(T.curr_method.labelMap.get(label));
        T.curr_method.resetBlock();
      }

      if(argu.toString() == "2"){
        System.out.println("\tJUMP " + T.curr_method.name + label + " ");
      }
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      String tmp1 ="";
      String tmp2 = "";
      String offset = "";
      if(argu.toString() == "1"){
        T.curr_method.setBlock(T.curr_method.addBlock());
      }

      n.f0.accept(this, argu);
      tmp1 = (String)n.f1.accept(this, argu);
      offset = (String)n.f2.accept(this, argu);
      tmp2 = (String)n.f3.accept(this, argu);
        
      if(argu.toString() == "1"){
        T.curr_method.curr_block.addUse(tmp1);
        T.curr_method.curr_block.addUse(tmp2);
        T.curr_method.resetBlock();
      }

      if(argu.toString() == "2"){ 
        if(T.curr_method.regMap.containsKey(tmp1)){
          if(T.curr_method.regMap.containsKey(tmp2)){
            System.out.println("\tHSTORE " + T.curr_method.regMap.get(tmp1) + " " + offset + " " + T.curr_method.regMap.get(tmp2) + " ");
          }
          else{
            System.out.println("\tALOAD v1 SPILLARG " + T.curr_method.spillMap.get(tmp2));
            System.out.println("\tHSTORE " + T.curr_method.regMap.get(tmp1) + " " + offset + " v1 ");
          }
        }
				else{
          if(T.curr_method.regMap.containsKey(tmp2)){
        	  System.out.println("\tALOAD v1 SPILLARG " + T.curr_method.spillMap.get(tmp1));
            System.out.println("\tHSTORE v1 " + " " + offset + " " + T.curr_method.regMap.get(tmp2) + " ");
          }
          else{
          	System.out.println("\tALOAD v0 SPILLARG " + T.curr_method.spillMap.get(tmp1));
            System.out.println("\tALOAD v1 SPILLARG " + T.curr_method.spillMap.get(tmp2));
            System.out.println("\tHSTORE v0 " + offset + " v1 ");
          }
        }
      }
	    return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      String tmp1 ="";
      String tmp2 = "";
      String offset = "";
      if(argu.toString().equals("1")){
        T.curr_method.setBlock(T.curr_method.addBlock());
      }

      n.f0.accept(this, argu);
      tmp1 = (String)n.f1.accept(this, argu);
      tmp2 = (String)n.f2.accept(this, argu);
      offset= (String)n.f3.accept(this, argu);

      if(argu.toString().equals("1")){
        T.curr_method.curr_block.addDef(tmp1);
        T.curr_method.curr_block.addUse(tmp2);
        T.curr_method.resetBlock();
      }

      if(argu.toString().equals("2")){
        if(T.curr_method.regMap.containsKey(tmp1)){
          if(T.curr_method.regMap.containsKey(tmp2)){
            System.out.println("\tHLOAD " + T.curr_method.regMap.get(tmp1) + " " + T.curr_method.regMap.get(tmp2) + " "+ offset +" ");
          }
          else{
            System.out.println("\tALOAD v1 SPILLARG " + T.curr_method.spillMap.get(tmp2) + " ");
            System.out.println("\tHLOAD " + T.curr_method.regMap.get(tmp1)  + " v1 " + offset+ " ");
          }
      	}
        else if(T.curr_method.spillMap.containsKey(tmp1)){
          if(T.curr_method.regMap.containsKey(tmp2)){
            System.out.println("\tHLOAD v1 " + T.curr_method.regMap.get(tmp2) + " "+ offset + " " );
            System.out.println("\tASTORE SPILLEDARG " + T.curr_method.spillMap.get(tmp1) + " v1 ");
          }
        	else{
          	System.out.println("\tALOAD v0 SPILLARG " + T.curr_method.spillMap.get(tmp2) + " ");
            System.out.println("\tHLOAD v1 " + " v0 " + offset+" ");
            System.out.println("\tASTORE SPILLEDARG " + T.curr_method.spillMap.get(tmp1) + " v1 ");
          }
        }
      }
    return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      String temp = "";
      String expr = "";
        
      if(argu.toString() == "1")
      	T.curr_method.setBlock(T.curr_method.addBlock());
        
      n.f0.accept(this, argu);
      temp = (String)n.f1.accept(this, argu);
      expr = (String)n.f2.accept(this, argu);

      if(argu.toString() == "1"){
        T.curr_method.curr_block.addDef(temp);
        T.curr_method.resetBlock();
      }

      if(argu.toString() == "2"){
        if(T.curr_method.regMap.containsKey(temp)){
          System.out.print("\tMOVE " + T.curr_method.regMap.get(temp) + " " + expr + "\n");
        }
        else if(T.curr_method.spillMap.containsKey(temp)){
          System.out.print("\tMOVE v1 "+ expr + "\n");
          System.out.println("\tASTORE SPILLEDARG " + T.curr_method.spillMap.get(temp) + " v1 ");
        }
      }
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      String inst0 = "";
      String inst1 = "";
      if(argu.toString() == "1"){
        T.curr_method.setBlock(T.curr_method.addBlock());
      }

      inst0 = (String)n.f0.accept(this, argu);
      inst1 = (String)n.f1.accept(this, argu);

      if(argu.toString() == "1"){
        T.curr_method.resetBlock();
      }

      if(argu.toString() == "2"){
        if(T.curr_method.regMap.containsKey(inst1)){
          System.out.println("\t" + inst0 + " " + T.curr_method.regMap.get(inst1) + " ");
        }
        else{
          System.out.println("\tALOAD v1 SPILLEDARG " + T.curr_method.spillMap.get(inst1)+ " ");
          System.out.println("\t" + inst0 + " v1 ");
        }
      }
	    return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      if(n.f0.which == 3){
        String str = (String)_ret;
        if(str.startsWith("TEMP")){
          if(T.curr_method.regMap.containsKey(str)){
            _ret = (R)T.curr_method.regMap.get(str);
          }
          else if(argu.toString() == "2"){
            System.out.println("\tALOAD v0 SPILLEDARG " + T.curr_method.spillMap.get(str));
            _ret = (R)("v0");           
          }
      	}
        else if(argu.toString().equals("2")){
        	try{
          	int x = Integer.parseInt(str);
            System.out.println("\tMOVE v1 "+ str);
            _ret = (R)("v1");
          }
          catch(Exception e){
            _ret = (R)str;
          }
        }      
      }
    	return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      String rval = "";
      switch(argu.toString()){
      	case "1":
        	n.f0.accept(this, argu);
          n.f1.accept(this, argu);
          n.f2.accept(this, argu);
          int addr = T.curr_method.addBlock();
          T.curr_method.setBlock(addr);
          n.f3.accept(this, argu);
          n.f4.accept(this, argu);
          T.curr_method.resetBlock();
          break;  
        case "2":
          n.f0.accept(this, argu);
          for(int i=0;i<=7;++i){
            System.out.println("\tASTORE SPILLEDARG "+(T.curr_method.sp + i) +" s" + i);
          }
          for(int i = 0; i < Math.min(4,Integer.parseInt(T.curr_method.argc)); i++){
            if(T.curr_method.regMap.containsKey("TEMP" + Integer.toString(i))){
              System.out.println("MOVE " + T.curr_method.regMap.get("TEMP" + Integer.toString(i)) + " a" + i);
            }
          }
          n.f1.accept(this, argu);
          n.f2.accept(this, argu);
          rval = (String)n.f3.accept(this, argu);
          if(rval.startsWith("TEMP")){
            if(T.curr_method.regMap.containsKey(rval)){
              System.out.println("\tMOVE v0 " + T.curr_method.regMap.get(rval));
            }
            else{
              System.out.println("\tALOAD v1 SPILLEDARG "+  T.curr_method.spillMap.get(rval));
              System.out.println("\tMOVE v0 v1 ");
            }
          }
          else{
	          System.out.println("\tMOVE v0 " + rval);
          }
          n.f4.accept(this, argu);
          for(int i = 0; i < 8 ; i++){
            System.out.println("\tALOAD s" + (i) +" SPILLEDARG " + (T.curr_method.sp +i));
          }
          System.out.println("END");
          break;
        }
	    return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
        
        if(argu.toString() == "2"){
            for(int i = 0; i < 10; i++){
                System.out.println("\tASTORE SPILLEDARG " + (T.curr_method.tp + i) + " t" + i);
            }
        }
        
        String tmp= "";
        String inst0= "";
        String inst1 = "";
        
        inst0 = (String)n.f0.accept(this, argu);
        inst1 = (String)n.f1.accept(this, argu);
        n.f2.accept(this, argu);
        
        if(n.f3.present()){
            if(argu.toString() == "1"){
                T.curr_method.callc = Math.max(T.curr_method.callc,n.f3.size());
            }
            
            for(int i=0; i<n.f3.size(); i++){
                tmp = (String)((Node)n.f3.elementAt(i)).accept(this,argu);
                if(argu.toString() == "1"){
                    T.curr_method.curr_block.addUse(tmp);
                }
                if(argu.toString() == "2"){
                    if(i < 4){
                        if(T.curr_method.regMap.containsKey(tmp)){
                            System.out.println("\tMOVE a" + i + " " + T.curr_method.regMap.get(tmp) + " ");
                        }
                        else{
                            System.out.println("\tALOAD v1 SPILLEDARG " + T.curr_method.spillMap.get(tmp) + " ");
                            System.out.println("\tMOVE a"+i +" v1 " );
                        }
                    }
                    else{
                        if(T.curr_method.regMap.containsKey(tmp)){
                            System.out.println("\tPASSARG "+ (i-3) + " "+ T.curr_method.regMap.get(tmp) + " ");
                        }
                        else{
                            System.out.println("\tALOAD v1 SPILLEDARG "+ T.curr_method.spillMap.get(tmp) + " ");
                            System.out.println("\tPASSARG "+ (i-3) + " v1 ");
                        }
                    }
                }
            }
        }

      if(argu.toString() == "2"){
        if(inst1.startsWith("TEMP")){
          if(T.curr_method.regMap.containsKey(inst1)){
          	System.out.println("\tCALL "  + T.curr_method.regMap.get(inst1) + " ");
 	      	}
        	else{
          	System.out.println("\tALOAD v1 SPILLEDARG "+T.curr_method.spillMap.get(inst1) + " ");
          	System.out.println("\tCALL v1 ");
    	  	}
        }
        else{
          System.out.println("\tCALL "+inst1);
        }
        for(int i = 0; i < 10; i++){
          System.out.println("\tALOAD t" + i + " SPILLEDARG " + (i+ T.curr_method.tp) + " ");
        }
      }

      n.f4.accept(this, argu);
      _ret = (R)("v0");
    	return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      String inst0 = "";
      String inst1 = "";
      inst0 = (String)n.f0.accept(this, argu);
      inst1 = (String)n.f1.accept(this, argu);
        
      if(argu.toString().equals("2")){
        if(inst1.startsWith("TEMP")){
          if(T.curr_method.regMap.containsKey(inst1)){
            System.out.println("\tMOVE v0 PLUS " +T.curr_method.regMap.get(inst1)+ " 8 " );
            _ret = (R)("HALLOCATE v0 ");
          }
					else{
          	System.out.println("\tALOAD v0 SPILLEDARG " + T.curr_method.spillMap.get(inst1));
          	System.out.println("\tMOVE v0 PLUS v0 8 ");
          	_ret = (R)("HALLOCATE v0 ");
          }
      	}
				else{
        	_ret = (R)(inst0 + " " + inst1);
        }
      }
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
        String inst0 = "";
        String inst1 = "";
        String inst2= "";
        inst0 = (String)n.f0.accept(this, argu);
        inst1 = (String)n.f1.accept(this, argu);
        
        if(argu.toString().equals("1")){
            T.curr_method.curr_block.addUse(inst1);    
        }

        inst2 = (String)n.f2.accept(this, argu);
      
        if(argu.toString().equals("2")){
            if(T.curr_method.regMap.containsKey(inst1)){
                if(inst2.startsWith("TEMP")){
                    if(T.curr_method.regMap.containsKey(inst2)){
                        _ret = (R)(inst0 + " " + T.curr_method.regMap.get(inst1) + " " + T.curr_method.regMap.get(inst2) + " ");
                    }
                    else{
                        System.out.println("\tALOAD v1 SPILLEDARG " + T.curr_method.spillMap.get(inst2));
                        _ret = (R)(inst0 + " " +T.curr_method.regMap.get(inst1) + " v1 ");
                    }
                }
                else{
                    _ret = (R)(inst0 + " " + T.curr_method.regMap.get(inst1) + " " + inst2 + " ");
                }
            }else{
                if(inst2.startsWith("TEMP")){
                    if(T.curr_method.regMap.containsKey(inst2)){
                        System.out.println("\tALOAD v1 SPILLEDARG "+  T.curr_method.spillMap.get(inst1));
                        _ret = (R)(inst0 + " v1 " +T.curr_method.regMap.get(inst2) + " ");
                    }

                    else{
                        System.out.println("\tALOAD v0 SPILLEDARG " + T.curr_method.spillMap.get(inst1));
                        System.out.println("\tALOAD v1 SPILLEDARG " + T.curr_method.spillMap.get(inst2));
                        _ret = (R)(inst0 + " v0 v1 ");
                    }
                }
                else{
                    System.out.println("\tALOAD v1 SPILLEDARG "+  T.curr_method.spillMap.get(inst1));
                    _ret = (R)(inst0 + " v1 " +inst2 + " ");

                }
            }
        }
        return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
			 if(n.f0.which == 0)
          if(argu.toString() == "1")
						T.curr_method.curr_block.addUse((String)_ret);
  
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      String temp = "";
      String val = "";
        
      temp = (String)n.f0.accept(this, argu);
      val = (String)n.f1.accept(this, argu);

      _ret = (R)(temp+val);
      if(argu.toString() == "1" && !T.curr_method.Temp.contains(temp+val))
        T.curr_method.Temp.add(temp+val);
    return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

}
